# Design and Analysis of Algorithms Laboratory

A comprehensive collection of algorithm design and analysis experiments covering fundamental algorithmic techniques, complexity analysis, and practical implementations. This repository contains hands-on implementations of classic algorithms with performance analysis and optimization strategies.

## Project Overview

This laboratory curriculum provides systematic exploration of algorithm design paradigms, complexity analysis techniques, and practical problem-solving approaches. The experiments progress from basic algorithmic concepts to advanced optimization techniques, building essential skills for computational problem solving.

## Key Technologies and Concepts

- **Algorithm Design Paradigms** - Divide and conquer, dynamic programming, greedy algorithms, backtracking
- **Complexity Analysis** - Time and space complexity evaluation using Big O, Theta, and Omega notations
- **Data Structure Integration** - Optimal data structure selection for algorithmic efficiency
- **Performance Optimization** - Algorithm tuning and empirical analysis techniques
- **Mathematical Analysis** - Recurrence relations, asymptotic analysis, and proof techniques

## Laboratory Categories

### Sorting and Searching Algorithms
Implementation and analysis of fundamental sorting algorithms including comparison-based and non-comparison-based methods. Performance evaluation across different input distributions and sizes.

### Graph Algorithms
Comprehensive graph algorithm implementations covering traversal, shortest path, minimum spanning tree, and network flow problems with complexity analysis.

### Dynamic Programming
Classical dynamic programming problems demonstrating optimal substructure and overlapping subproblems principles with memoization and tabulation approaches.

### Greedy Algorithms
Greedy algorithm design and analysis with proof techniques for optimal solutions and counterexamples for non-optimal cases.

### Divide and Conquer
Implementation of divide and conquer algorithms with recurrence relation analysis and master theorem applications.

### Backtracking and Branch & Bound
Systematic exploration algorithms for constraint satisfaction problems and optimization with pruning strategies.

### String Algorithms
Pattern matching algorithms, string processing techniques, and text analysis with efficiency comparisons.

### Numerical Algorithms
Mathematical algorithm implementations for computational geometry, number theory, and numerical analysis problems.

## Learning Outcomes

This laboratory curriculum provides practical experience with:
- Algorithm design and implementation techniques
- Theoretical and empirical complexity analysis
- Performance optimization and algorithm tuning
- Mathematical proof techniques for algorithm correctness
- Problem-solving strategy selection and justification
- Comparative analysis of algorithmic approaches
- Real-world application of theoretical concepts

Each experiment combines theoretical understanding with practical implementation, reinforcing algorithm design principles through hands-on coding and analysis.

## Complete List of Experiments

### Day 1 - Basic Algorithm Analysis
1.1 Time and Space Complexity Analysis of Basic Operations
1.2 Empirical Analysis of Algorithm Performance
1.3 Best, Average, and Worst Case Analysis
1.4 Asymptotic Notation Implementation and Verification
1.5 Recursive Algorithm Analysis with Recurrence Relations

### Day 2 - Sorting Algorithms
2.1 Implementation and Analysis of Bubble Sort
2.2 Implementation and Analysis of Selection Sort
2.3 Implementation and Analysis of Insertion Sort
2.4 Implementation and Analysis of Merge Sort
2.5 Implementation and Analysis of Quick Sort
2.6 Comparative Performance Analysis of Sorting Algorithms

### Day 3 - Advanced Sorting and Searching
3.1 Heap Sort Implementation and Analysis
3.2 Radix Sort and Counting Sort Implementation
3.3 Binary Search and Variants
3.4 Interpolation Search and Exponential Search
3.5 Order Statistics and Selection Algorithms

### Day 4 - Divide and Conquer
4.1 Maximum Subarray Problem (Kadane's Algorithm)
4.2 Closest Pair of Points Problem
4.3 Matrix Multiplication (Strassen's Algorithm)
4.4 Fast Fourier Transform Implementation
4.5 Recurrence Relation Solving Techniques

### Day 5 - Dynamic Programming Part 1
5.1 Fibonacci Sequence Optimization
5.2 Longest Common Subsequence Problem
5.3 0/1 Knapsack Problem Implementation
5.4 Coin Change Problem and Variants
5.5 Edit Distance (Levenshtein Distance)

### Day 6 - Dynamic Programming Part 2
6.1 Matrix Chain Multiplication
6.2 Longest Increasing Subsequence
6.3 Subset Sum Problem
6.4 Palindrome Partitioning
6.5 Maximum Sum Increasing Subsequence

### Day 7 - Greedy Algorithms
7.1 Activity Selection Problem
7.2 Fractional Knapsack Problem
7.3 Job Scheduling with Deadlines
7.4 Huffman Coding Implementation
7.5 Minimum Number of Coins Problem

### Day 8 - Graph Algorithms Part 1
8.1 Graph Representation and Basic Operations
8.2 Depth-First Search and Applications
8.3 Breadth-First Search and Applications
8.4 Topological Sorting Implementation
8.5 Connected Components Detection

### Day 9 - Graph Algorithms Part 2
9.1 Shortest Path Algorithms (Dijkstra's Algorithm)
9.2 All-Pairs Shortest Path (Floyd-Warshall)
9.3 Bellman-Ford Algorithm for Negative Weights
9.4 Minimum Spanning Tree (Kruskal's Algorithm)
9.5 Minimum Spanning Tree (Prim's Algorithm)

### Day 10 - Advanced Graph Algorithms
10.1 Maximum Flow Problem (Ford-Fulkerson)
10.2 Bipartite Matching Algorithm
10.3 Strongly Connected Components
10.4 Articulation Points and Bridges
10.5 Graph Coloring Problem

### Day 11 - Backtracking Algorithms
11.1 N-Queens Problem Implementation
11.2 Sudoku Solver Algorithm
11.3 Graph Coloring using Backtracking
11.4 Hamiltonian Path and Cycle
11.5 Subset Generation and Permutations

### Day 12 - Branch and Bound
12.1 Traveling Salesman Problem using Branch and Bound
12.2 0/1 Knapsack using Branch and Bound
12.3 Job Assignment Problem
12.4 8-Puzzle Problem Solution
12.5 Branch and Bound vs Backtracking Analysis

### Day 13 - String Algorithms
13.1 Naive String Matching Algorithm
13.2 KMP (Knuth-Morris-Pratt) Algorithm
13.3 Rabin-Karp Algorithm Implementation
13.4 Boyer-Moore String Matching
13.5 Longest Common Prefix Problem

### Day 14 - Advanced String Processing
14.1 Suffix Array Construction
14.2 Z Algorithm Implementation
14.3 Manacher's Algorithm for Palindromes
14.4 Aho-Corasick Algorithm
14.5 String Hashing Techniques

### Day 15 - Computational Geometry
15.1 Convex Hull Problem (Graham Scan)
15.2 Line Intersection Detection
15.3 Point in Polygon Problem
15.4 Closest Pair of Points in 2D
15.5 Geometric Range Queries

### Day 16 - Number Theory Algorithms
16.1 Prime Number Generation (Sieve of Eratosthenes)
16.2 Greatest Common Divisor (Euclidean Algorithm)
16.3 Modular Exponentiation
16.4 Chinese Remainder Theorem
16.5 Primality Testing Algorithms

### Day 17 - Advanced Data Structures and Algorithms
17.1 Disjoint Set Union (Union-Find) Implementation
17.2 Segment Tree Construction and Queries
17.3 Binary Indexed Tree (Fenwick Tree)
17.4 Trie Data Structure and Applications
17.5 Suffix Tree Construction

### Day 18 - Algorithm Optimization and Analysis
18.1 Cache-Efficient Algorithm Design
18.2 Parallel Algorithm Implementation
18.3 Approximation Algorithms
18.4 Randomized Algorithm Implementation
18.5 Algorithm Performance Profiling and Optimization
